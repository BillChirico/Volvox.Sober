# Volvox.Sober Development Guidelines

Last updated: 2025-11-06

## Project Overview

Volvox.Sober is a universal Expo application (iOS, Android, Web) for sobriety support and recovery, enabling authentic peer accountability through curated sponsor/sponsee matching.

## Technology Stack

### Frontend (Universal App)

- **Platform**: Expo 54.x (universal app platform)
- **Framework**: React Native 0.81+
- **Language**: TypeScript 5.x (strict mode)
- **Navigation**: Expo Router 4.x (file-based routing)
- **State Management**: Redux Toolkit + Redux Persist
- **Form Handling**: Yup validation
- **UI**: React Native Paper with custom theme system
- **Testing**: Jest + React Native Testing Library + Playwright (E2E)
- **Authentication**: Supabase Auth SDK (@supabase/supabase-js)

### Backend (Supabase)

- **Database**: PostgreSQL 15+
- **Authentication**: Supabase Auth (GoTrue)
- **Real-time**: Supabase Realtime subscriptions
- **Functions**: Supabase Edge Functions (Node.js 18+ / Deno runtime)
- **Storage**: Row Level Security (RLS)

### Package Manager

- **pnpm**: 10.20.0 (monorepo workspace structure)

## Project Structure

```
volvox-sober/
├── app/                 # Expo Router (file-based routing)
│   ├── (tabs)/          # Tab navigation group
│   │   ├── _layout.tsx
│   │   ├── connections.tsx
│   │   ├── matches.tsx
│   │   ├── messages.tsx
│   │   ├── sobriety.tsx
│   │   └── profile.tsx
│   ├── (auth)/          # Auth screens group
│   │   ├── _layout.tsx
│   │   ├── login.tsx
│   │   ├── signup.tsx
│   │   ├── forgot-password.tsx
│   │   └── verify-email.tsx
│   ├── (onboarding)/    # Onboarding screens group
│   │   ├── _layout.tsx
│   │   ├── welcome.tsx
│   │   ├── email-verification.tsx
│   │   ├── sponsor-profile.tsx
│   │   └── sponsee-profile.tsx
│   ├── _layout.tsx      # Root layout with providers
│   ├── index.tsx        # Entry route (redirect logic)
│   └── +not-found.tsx   # 404 page
│
├── src/                 # Application source code
│   ├── components/      # Reusable UI components
│   │   ├── auth/        # Authentication-specific components
│   │   └── common/      # Shared components (AccessibleButton, etc.)
│   ├── services/        # API clients, business logic
│   │   ├── authService.ts # Supabase Auth integration
│   │   └── validationSchemas.ts # Yup validation schemas
│   ├── store/           # State management (Redux Toolkit)
│   │   └── auth/        # Auth state slice, selectors, thunks
│   ├── types/           # TypeScript definitions
│   │   └── auth.ts      # Authentication types
│   ├── hooks/           # Custom React hooks
│   │   ├── useAuth.ts   # Auth operations hook
│   │   └── useAuthRedirect.ts # Navigation hook
│   ├── theme/           # Theme tokens and provider
│   ├── constants/       # App constants (Colors, Layout)
│   └── utils/           # Utility functions
│       └── passwordStrength.ts # Password strength calculator
│
├── __tests__/           # Test files
├── assets/              # Images, fonts, static resources
├── ios/                 # iOS native code (generated by Expo)
├── android/             # Android native code (generated by Expo)
├── web/                 # Web-specific code and configuration
├── e2e/                 # End-to-end tests (Detox)
│
├── packages/
│   └── shared/          # Shared code (types, utilities)
│       └── types/       # TypeScript type definitions
│
├── supabase/            # Backend
│   ├── migrations/      # Database schema migrations
│   ├── functions/       # Edge Functions
│   └── seed.sql         # Test data seeding
│
├── specs/               # Feature specifications & planning
│   └── 001-auth-screens/
│       ├── spec.md      # Feature specification
│       ├── plan.md      # Implementation plan
│       ├── research.md  # Technical decisions
│       ├── data-model.md # Database design
│       ├── quickstart.md # Local development guide
│       ├── contracts/   # API contract specifications
│       │   ├── auth.yaml # Supabase Auth contracts
│       │   └── README.md
│       └── tasks.md     # Work packages (generated by /speckit.tasks)
│
├── docs/                # Project documentation
└── scripts/             # Build and utility scripts
```

### Platform-Specific Files

Expo supports platform-specific implementations:

- `Component.tsx` - Shared across all platforms
- `Component.ios.tsx` - iOS-specific override
- `Component.android.tsx` - Android-specific override
- `Component.web.tsx` - Web-specific override

### Important: Screen Organization

**All screen components MUST be in the `app/` directory using Expo Router's file-based routing.**

- ✅ **Correct**: Create screens in `app/(tabs)/`, `app/(auth)/`, `app/(onboarding)/`, etc.
- ❌ **Incorrect**: DO NOT create screens in `src/screens/` (deprecated)
- The `src/` directory is for reusable components, services, hooks, and utilities only
- Screens in `app/` use Expo Router's automatic routing based on file structure

## Commands

### Development

```bash
# Start Expo dev server
pnpm start

# Run on iOS
pnpm ios

# Run on Android
pnpm android

# Run on Web
pnpm web
```

### Quality Checks

```bash
# Run all tests
pnpm test

# Type checking
pnpm typecheck

# Linting
pnpm lint
pnpm lint:fix

# Code formatting
pnpm format
```

## Code Style

### TypeScript

- **Strict mode enabled**: No implicit any, strict null checks
- **Interfaces over types**: Prefer interface for object shapes
- **Explicit return types**: For all exported functions
- **No `any`**: Use `unknown` or proper types

### React Native

- **Functional components**: Use hooks, no class components
- **Named exports**: Prefer named exports over default
- **Component structure**: Props interface → Component → Styles
- **Hooks order**: useState → useEffect → custom hooks → handlers

### File Naming

- **Components**: PascalCase (`Button.tsx`, `UserProfile.tsx`)
- **Hooks**: camelCase with `use` prefix (`useAuth.ts`)
- **Services**: camelCase (`authService.ts`, `messageService.ts`)
- **Types**: PascalCase (`User.ts`, `Message.ts`)
- **Tests**: Mirror source with `.test.tsx` suffix

### Testing

- **Unit tests**: Jest + React Native Testing Library
- **E2E tests**: Playwright (web testing and automation)
- **Coverage target**: 80% minimum for business logic
- **Test location**: Co-located `__tests__` directories
- **TDD Required**: Write tests first, verify failure, implement, verify pass, refactor

## Development Workflow

1. **Branch from main**: Create feature branch from `main`
2. **Follow TDD**: Write tests first for new features
3. **Type safety**: Ensure TypeScript strict mode compliance
4. **Quality checks**: Always run in this order when editing or adding files:
   ```bash
   pnpm lint:fix    # Linting with auto-fix (includes Prettier formatting)
   pnpm typecheck   # TypeScript validation
   pnpm test        # Run test suite
   ```
5. **Commit and push**: After completing all tasks, commit changes and push to remote
6. **Commit messages**: Conventional commits with scope (feat(scope):, fix(scope):, docs(scope):, etc.)

## Environment Setup

1. **Node.js**: 18.0.0 or higher
2. **pnpm**: 8.0.0 or higher
3. **Expo CLI**: Installed automatically with dependencies
4. **iOS**: Xcode 14+ (macOS only)
5. **Android**: Android Studio + SDK 33+
6. **Web**: Modern browser (Chrome, Firefox, Safari, Edge)

Copy `.env.example` to `.env` and configure environment variables.

## Key Memories

Project has documented memories for:

- `project_overview`: Core features and technical stack
- `codebase_structure`: Directory layout and patterns
- `tdd_workflow`: Test-driven development approach
- `code_style_conventions`: Coding standards
- `task_completion_checklist`: Pre-commit checklist
- `constitution`: Project-wide quality standards and principles

## Constitution Principles

Six core principles govern all development (see `.specify/memory/constitution.md`):

1. **Type Safety & Code Quality**: TypeScript strict mode, no `any`, explicit return types
2. **Test-Driven Development**: TDD mandatory, 80% coverage, RED-GREEN-REFACTOR cycle
3. **Cross-Platform UX Consistency**: WCAG 2.1 AA, React Native Paper, accessibility-first
4. **Performance Standards**: <3s startup, 60 FPS, bundle size limits
5. **Component Architecture**: Functional components, hooks order, state management hierarchy
6. **Security & Privacy**: Supabase Auth only, RLS enabled, dual validation (client + server)

## Current Status

- **Phase**: Phase 10 - Polish & Cross-Cutting Concerns (Final Phase)
- **Active Feature**: `002-app-screens` (App Screen Implementation)
- **Active Branch**: `002-app-screens`
- **Completed Work**:
  - ✅ Project setup with Expo Router file-based routing
  - ✅ Authentication screens in app/(auth)/
  - ✅ Onboarding screens in app/(onboarding)/
  - ✅ Tab navigation screens in app/(tabs)/
  - ✅ Core components, hooks, and services
  - ✅ State management with Redux Toolkit + Redux Persist
  - ✅ Real-time messaging with Supabase subscriptions
  - ✅ Profile management with role switching
  - ✅ Settings screens (notifications, theme, account)
  - ✅ Accessibility testing (Playwright E2E + manual checklists)
  - ✅ Dark mode with Material Design 3 theming
  - ✅ Comprehensive E2E test coverage (9 Playwright test suites)
  - ✅ Performance optimizations (image lazy loading, list virtualization)
  - ✅ Error handling (ErrorBoundary, ErrorMessage, NetworkIndicator)
- **Current Focus**: Final validation and documentation
- **Note**: All screen components now reside in app/ directory using Expo Router. The old src/screens/ directory is deprecated and should not be used.

## MCP Server Usage Requirements

**CRITICAL**: You MUST use MCP servers for the following scenarios. Failure to use appropriate MCP servers when available is a violation of project standards.

### Quick Decision Matrix

```
Task Type → MCP Server:
├─ Database/Auth operations → Supabase MCP
├─ Symbol operations (rename, find refs) → Serena MCP
├─ Complex debugging/analysis → Sequential MCP
├─ Bulk code transformations → Morphllm MCP
├─ Official docs lookup → Context7 MCP
├─ Current information/research → Tavily MCP
└─ E2E/browser testing → Playwright MCP
```

### Supabase MCP (`mcp__supabase__*`)

**Trigger Keywords**: `migration`, `database`, `schema`, `supabase auth`, `edge function`, `RLS`, `postgres`, `query`, `table`

**Required for**:

- All Supabase database operations (migrations, queries, schema)
- Supabase Auth configuration and troubleshooting
- Edge Functions deployment and testing
- Database schema verification
- RLS policy management

**When to use**:

- Creating or modifying database migrations
- Testing Supabase Auth flows
- Querying database for debugging
- Deploying Edge Functions
- Verifying database state

**Project-specific examples**:

```bash
# Create profiles table migration
mcp__supabase__apply_migration

# Test email verification flow
mcp__supabase__execute_sql

# Deploy message processing function
mcp__supabase__deploy_edge_function

# Check Auth user state
mcp__supabase__get_logs --service auth
```

**Integration patterns**:

- Sequential → Supabase: Plan schema → Execute migration
- Serena → Supabase: Analyze code → Update DB to match
- Playwright → Supabase: Test E2E → Verify DB state

### Serena MCP (`mcp__serena__*`)

**Trigger Keywords**: `rename`, `find references`, `symbol`, `refactor`, `project memory`, `architecture`, `navigate codebase`, `find all uses`

**Required for**:

- Symbol operations (rename, find references, semantic search)
- Large codebase navigation (>50 files)
- Project memory management
- Cross-file refactoring
- Architectural analysis

**When to use**:

- Renaming functions/classes across multiple files
- Finding all usages of a symbol
- Understanding code architecture
- Storing/retrieving project context
- Multi-file semantic operations

**Project-specific examples**:

```bash
# Rename authService method across codebase
mcp__serena__rename_symbol

# Find all references to useAuth hook
mcp__serena__find_referencing_symbols

# Get overview of auth components
mcp__serena__get_symbols_overview

# Store architectural decisions
mcp__serena__write_memory
```

**Integration patterns**:

- Serena → Morphllm: Find symbols → Apply pattern edits
- Sequential → Serena: Analyze → Store insights
- Serena → Context7: Get context → Lookup patterns

### Sequential MCP (`mcp__sequential__*`)

**Trigger Keywords**: `--think`, `debug complex`, `analyze`, `root cause`, `architecture decision`, `hypothesis`, `multi-step`, `systematic`

**Required for**:

- Complex debugging scenarios
- Multi-step reasoning problems
- Architectural decision analysis
- Root cause investigation
- System design questions

**When to use**:

- `--think` flag: Standard structured analysis (~4K tokens)
- `--think-hard` flag: Deep architectural analysis (~10K tokens)
- `--ultrathink` flag: Critical system redesign (~32K tokens)
- Problems with 3+ interconnected components
- Hypothesis testing and validation

**Project-specific examples**:

```bash
# Debug auth flow performance issue
--think "Why is login taking 5+ seconds?"

# Analyze state management architecture
--think-hard "Should we add Redux Saga?"

# Critical navigation refactoring
--ultrathink "Migrate all screens to Expo Router"
```

**Integration patterns**:

- Sequential → Context7: Analyze → Lookup official patterns
- Sequential → Serena: Reason → Store insights
- Sequential → Supabase: Investigate → Query DB for evidence

### Morphllm MCP (`mcp__morphllm__*`)

**Trigger Keywords**: `bulk edit`, `pattern transformation`, `update all`, `enforce style`, `framework migration`, `replace across files`

**Required for**:

- Bulk code transformations
- Pattern-based edits across multiple files
- Style guide enforcement
- Framework migrations

**When to use**:

- Updating multiple files with same pattern
- Enforcing coding standards across codebase
- Token-efficient bulk operations
- Simple to moderate complexity edits (<10 files)

**Choose Morphllm over**:

- Native Edit: When editing 3+ files with same pattern
- Serena: For pattern edits, not symbol operations

**Project-specific examples**:

```bash
# Update all class components to functional
mcp__morphllm__edit_file

# Enforce explicit return types project-wide
mcp__morphllm__edit_file

# Replace all Stylesheet.create with themed styles
mcp__morphllm__edit_file
```

**Integration patterns**:

- Serena → Morphllm: Analyze symbols → Apply edits
- Sequential → Morphllm: Plan changes → Execute bulk edits
- Context7 → Morphllm: Get pattern → Apply across files

### Context7 MCP (`mcp__context7__*`)

**Trigger Keywords**: `import`, `require`, `docs`, `API reference`, `best practices`, `official documentation`, `framework patterns`, library versions`

**Required for**:

- Official library documentation lookup
- Framework-specific patterns (React, React Native, Expo)
- API reference validation
- Version-specific implementation

**When to use**:

- Need React Native Paper component docs
- Verifying Expo Router patterns
- Redux Toolkit best practices
- Supabase JS SDK documentation

**Choose Context7 over**:

- Tavily: For official docs, not general search
- Native knowledge: For current/version-specific patterns

**Project-specific examples**:

```bash
# Look up React Native Paper Button API
mcp__context7__resolve-library-id "react-native-paper"
mcp__context7__get-library-docs

# Verify Expo Router best practices
mcp__context7__get-library-docs "/expo/expo"

# Check Redux Toolkit RTK Query patterns
mcp__context7__get-library-docs "/reduxjs/redux-toolkit"
```

**Integration patterns**:

- Context7 → Sequential: Get patterns → Analyze design
- Context7 → Morphllm: Get pattern → Apply bulk edits
- Sequential → Context7: Analyze → Lookup official patterns

### Tavily MCP (`mcp__tavily__*`)

**Trigger Keywords**: `search`, `research`, `latest`, `current`, `best practices 2024/2025`, `breaking changes`, `new features`, `community solutions`

**Required for**:

- Web search for current information
- Library/framework updates research
- Best practices research
- External documentation lookup

**When to use**:

- Need current best practices
- Researching new libraries
- Finding external resources
- Checking for breaking changes

**Choose Tavily over**:

- Context7: For general search, not official docs
- Native knowledge: For post-2025 information

**Project-specific examples**:

```bash
# Research latest Expo Router patterns
mcp__tavily__search "Expo Router 4.x navigation patterns 2025"

# Find React Native performance solutions
mcp__tavily__search "React Native 0.81 performance optimization"

# Check for Supabase Auth updates
mcp__tavily__search "Supabase Auth breaking changes 2025"
```

**Integration patterns**:

- Tavily → Sequential: Research → Analyze findings
- Tavily → Context7: Find updates → Get official docs
- Sequential → Tavily: Identify gaps → Research solutions

### Playwright MCP (`mcp__playwright__*`)

**Trigger Keywords**: `E2E test`, `browser test`, `user flow`, `integration test`, `screenshot`, `accessibility test`, `WCAG`, `visual regression`

**Required for**:

- E2E testing
- Browser automation
- Visual regression testing
- Accessibility testing

**When to use**:

- Testing user flows
- Screenshot comparisons
- Accessibility compliance validation
- Cross-browser testing

**Not for**:

- Unit tests (use Jest + React Native Testing Library)
- Static code analysis
- Logic validation without browser

**Project-specific examples**:

```bash
# Test registration flow
mcp__playwright__browser_navigate
mcp__playwright__browser_fill_form
mcp__playwright__browser_click

# Validate login accessibility
mcp__playwright__browser_snapshot

# Take responsive screenshots
mcp__playwright__browser_take_screenshot
```

**Integration patterns**:

- Sequential → Playwright: Plan tests → Execute E2E
- Playwright → Supabase: Test flow → Verify DB state
- Context7 → Playwright: Get accessibility patterns → Test compliance

## Common MCP Workflows for This Project

### Authentication Feature Development

```
1. Research → Tavily: "Supabase Auth best practices 2025"
2. Documentation → Context7: Get Supabase Auth SDK docs
3. Analysis → Sequential: Design auth flow architecture
4. Database → Supabase: Create users/profiles tables
5. Implementation → Native tools: Create login/signup forms
6. Testing → Playwright: Test complete auth flow
7. Memory → Serena: Store auth patterns and decisions
```

### Component Development

```
1. Documentation → Context7: React Native Paper component API
2. Implementation → Native tools: Create accessible component
3. Testing → Playwright: Accessibility validation
4. Integration → Serena: Find integration points
5. Memory → Serena: Store component patterns
```

### Debugging Complex Issues

```
1. Analysis → Sequential: --think "Root cause investigation"
2. Code Search → Serena: Find all related symbols
3. Database Check → Supabase: Query for data issues
4. Research → Tavily: Search for similar issues
5. Documentation → Context7: Verify API usage
6. Testing → Playwright: Reproduce in browser
```

### Bulk Refactoring

```
1. Analysis → Sequential: Plan refactoring strategy
2. Symbol Search → Serena: Find all affected symbols
3. Pattern Application → Morphllm: Apply bulk edits
4. Verification → Playwright: Test affected flows
5. Memory → Serena: Document refactoring patterns
```

### Performance Optimization

```
1. Analysis → Sequential: --think "Performance bottlenecks"
2. Research → Tavily: "React Native 0.81 performance"
3. Documentation → Context7: React Native optimization
4. Code Review → Serena: Find optimization candidates
5. Implementation → Morphllm: Apply optimizations
6. Testing → Playwright: Measure improvements
```

## MCP Selection Decision Tree

```
Question: What are you trying to accomplish?

├─ Database/Backend
│  ├─ Supabase operations? → Supabase MCP
│  └─ Other backend? → Native tools
│
├─ Code Operations
│  ├─ Rename/find references? → Serena MCP
│  ├─ Bulk edits (3+ files)? → Morphllm MCP
│  └─ Single file edit? → Native Edit
│
├─ Analysis/Debugging
│  ├─ Complex (3+ components)? → Sequential MCP (--think/--think-hard)
│  └─ Simple issue? → Native reasoning
│
├─ Information/Research
│  ├─ Official documentation? → Context7 MCP
│  ├─ Current information? → Tavily MCP
│  └─ Basic explanation? → Native knowledge
│
└─ Testing
   ├─ E2E/Browser tests? → Playwright MCP
   └─ Unit tests? → Jest + Native tools
```

## MCP Anti-Patterns (What NOT to Do)

❌ **DON'T**: Use native Edit for 3+ files when Morphllm can batch
✅ **DO**: Use Morphllm for pattern-based bulk edits

❌ **DON'T**: Search web for official docs when Context7 has them
✅ **DO**: Use Context7 for React Native/Expo/Supabase docs

❌ **DON'T**: Use Sequential for simple explanations
✅ **DO**: Reserve Sequential for complex, multi-component analysis

❌ **DON'T**: Use Serena rename without checking references first
✅ **DO**: Use find_referencing_symbols before rename operations

❌ **DON'T**: Write manual browser automation when Playwright exists
✅ **DO**: Use Playwright MCP for all browser testing

❌ **DON'T**: Query Supabase without using Supabase MCP
✅ **DO**: Always use Supabase MCP for database operations

## Enforcement

If you fail to use an appropriate MCP server when one is clearly applicable, you MUST:

1. Stop the current operation
2. Acknowledge the oversight
3. Restart using the correct MCP server

This is not optional - MCP servers are project infrastructure and must be used when available.

### Violation Examples

```
❌ User: "Find all uses of useAuth"
   → Using Grep instead of Serena find_referencing_symbols

❌ User: "Update all imports to use @/"
   → Using multiple Edit calls instead of Morphllm

❌ User: "Test the signup flow"
   → Writing unit tests instead of Playwright E2E tests

❌ User: "Check React Native Paper Button API"
   → Using Tavily instead of Context7

❌ User: "Why is login slow?"
   → Using native reasoning instead of Sequential --think
```

<!-- MANUAL ADDITIONS START -->
<!-- MANUAL ADDITIONS END -->

## Active Technologies

- Expo Router 4.x (file-based routing) - 002-app-screens
- TypeScript 5.x (strict mode enabled) - 002-app-screens
- Redux Toolkit + Redux Persist - State management
- React Native Paper - UI component library
- Supabase - Backend (Auth, Database, Realtime)

## Recent Changes (002-app-screens branch)

### Screen Migration (Phase 1-9)

- ✅ **COMPLETED**: Full migration from React Navigation to Expo Router
- ✅ **DELETED** `src/screens/` directory - all 32 screens migrated to `app/`
- ✅ Authentication screens: login, signup, forgot-password, verify-email (app/(auth)/)
- ✅ Onboarding screens: welcome, role-selection, email-verification, profiles (app/(onboarding)/)
- ✅ Main tab screens: connections, matches, messages, sobriety, profile (app/(tabs)/)
- ✅ Connections sub-routes: [id], pending, send, sent (app/(tabs)/connections/)
- ✅ Messages sub-routes: [id] (app/(tabs)/messages/)
- ✅ Profile sub-routes: edit, view, change-role (app/(tabs)/profile/)
- ✅ Sobriety sub-routes: log-relapse, history, set-date (app/(tabs)/sobriety/)
- ✅ Steps sub-routes: index, work/[id], history (app/(tabs)/steps/)
- ✅ Check-ins sub-routes: response, schedule (app/(tabs)/check-ins/)
- ✅ Settings sub-routes: notifications, theme, account (app/(tabs)/settings/)
- ✅ Reviews sub-routes: sponsor (app/(tabs)/reviews/)

**Migration Status**: All screens converted from `useNavigation/useRoute` to `useRouter/useLocalSearchParams`

### Component Patterns (Phase 10)

**Profile Components** (src/components/profile/):
- `ProfileHeader.tsx`: Reusable profile header with avatar, name, role, and stats
  - Pattern: Composition with Material Design 3 Card and Surface
  - Features: Avatar display, user info, sobriety stats, action buttons
- `SettingsSection.tsx`: Themed settings section container
  - Pattern: Section header with divider, consistent spacing
  - Features: Icon support, nested List.Item integration
- `NotificationSettings.tsx`: Comprehensive notification preferences management
  - Pattern: Switch controls with descriptions, grouped by category
  - Features: Async state updates, loading indicators, accessibility labels

**Error Handling Components** (src/components/common/):
- `ErrorBoundary.tsx`: React error boundary with retry functionality
- `ErrorMessage.tsx`: Styled error display with retry actions
- `NetworkIndicator.tsx`: Connection status indicator with auto-hide

### State Management Patterns

**Redux Toolkit with RTK Query**:
- Pattern: Feature-based slices with colocated selectors and thunks
- Example: `src/store/messages/` contains messagesSlice, messagesSelectors, messagesThunks
- Thunk pattern: `createAsyncThunk` with typed responses and error handling
- Selector pattern: Memoized selectors with `createSelector` for derived data

**Real-time Subscriptions** (src/hooks/useMessages.ts):
```typescript
// Pattern: Custom hook with Supabase Realtime
const subscription = supabase
  .channel('messages')
  .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' },
    (payload) => dispatch(addMessage(payload.new))
  )
  .subscribe()

// Cleanup: useEffect return function
return () => { subscription.unsubscribe() }
```

**Optimistic Updates**:
- Pattern: Dispatch optimistic update → API call → Confirm/rollback
- Example: messagesSlice uses `addMessage` before API confirmation
- Error handling: Rollback on failure with user notification

**Redux Persist**:
- Pattern: Selective persistence with AsyncStorage
- Configuration: Root store with persistConfig for specific reducers
- Usage: Messages, profile, preferences persisted; auth session expires

### Theme System (src/theme/)

**Material Design 3 with Dark Mode**:
- `index.ts`: Theme tokens with WCAG AA compliant colors
  - Light theme: `#007AFF` primary (iOS Blue, 4.5:1 contrast)
  - Dark theme: `#66B3FF` primary (8.5:1 contrast on dark surface)
  - Semantic colors: primary, secondary, error, surface, background
- `ThemeContext.tsx`: Theme provider with system detection
  - Pattern: React Context with AsyncStorage persistence
  - Features: System theme detection via `useColorScheme`
  - Auto-switching: Respects system preference when mode is 'system'
- `app/(tabs)/settings/theme.tsx`: Theme selection UI
  - Pattern: RadioButton group with three modes (light, dark, system)
  - Features: Loading state during theme change, accessibility labels

**Theme Usage Pattern**:
```typescript
import { useAppTheme } from '@/theme/ThemeContext'

const { theme, isDark, themeMode, setThemeMode } = useAppTheme()

// Use theme.colors for dynamic styling
<View style={{ backgroundColor: theme.colors.surface }}>
  <Text style={{ color: theme.colors.onSurface }}>Content</Text>
</View>
```

### Navigation Patterns (Expo Router)

**File-based Routing**:
- Directory structure defines routes automatically
- Groups: `(tabs)`, `(auth)`, `(onboarding)` for logical organization
- Dynamic routes: `[id].tsx` for parameterized paths
- Layout files: `_layout.tsx` for shared UI and navigation config

**Navigation Hooks**:
```typescript
import { useRouter, useLocalSearchParams } from 'expo-router'

// Navigate programmatically
const router = useRouter()
router.push('/profile/edit')
router.replace('/auth/login')
router.back()

// Access route parameters
const { id } = useLocalSearchParams<{ id: string }>()
```

**Deep Linking**:
- Pattern: URL scheme configured in app.json
- Format: `volvox://app/(tabs)/profile/edit`
- Automatic handling by Expo Router

### Accessibility Patterns

**WCAG 2.1 AA Compliance**:
- Minimum touch targets: 44x44 pixels (verified in accessibility.spec.ts)
- Color contrast: 4.5:1 for normal text, 3:1 for large text
- Screen reader support: aria-label, accessibilityLabel, accessibilityRole
- Keyboard navigation: Focus indicators, tab order, keyboard shortcuts

**Screen Reader Testing**:
- iOS VoiceOver: Manual testing checklist (__tests__/voiceover-testing-checklist.md)
- Android TalkBack: Manual testing checklist (__tests__/talkback-testing-checklist.md)
- Critical flows: Auth, onboarding, matches, connections, messages, sobriety, profile

**Accessibility Props Pattern**:
```typescript
<TouchableOpacity
  accessibilityLabel="Send message"
  accessibilityRole="button"
  accessibilityHint="Double tap to send the message"
>
  <Icon name="send" />
</TouchableOpacity>
```

### Testing Patterns

**E2E Testing with Playwright** (__tests__/*.spec.ts):
- 9 comprehensive test suites covering all user flows
- Patterns: Login helper, navigation helpers, element verification
- Cross-browser: Chromium (default), Firefox, WebKit
- Accessibility: Automated WCAG AA validation in accessibility.spec.ts
- Dark mode: Comprehensive theming tests in dark-mode.spec.ts

**Test Organization**:
```
__tests__/
├── *.spec.ts           # Playwright E2E tests (excluded from Jest)
├── components/         # Component unit tests (Jest)
├── store/             # Redux state tests (Jest)
└── services/          # Service layer tests (Jest)
```

**E2E Test Pattern**:
```typescript
test.describe('Feature Flow', () => {
  test.beforeEach(async ({ page }) => {
    await login(page) // Helper function
  })

  test('User can complete action', async ({ page }) => {
    await page.click('[data-testid="action-button"]')
    await expect(page.locator('[data-testid="success"]')).toBeVisible()
  })
})
```

### Performance Patterns

**Image Lazy Loading**:
- Pattern: React Native Paper Avatar with loading prop
- Optimization: Only load images when components are visible
- Fallback: Placeholder initials for missing avatars

**List Virtualization**:
- Pattern: FlatList with optimized props
- Props: `removeClippedSubviews`, `maxToRenderPerBatch`, `windowSize`
- Use case: Messages list, connections list, matches list

**Redux Persist Configuration**:
- Pattern: Selective persistence to reduce AsyncStorage load
- Persist: User profile, preferences, non-sensitive cached data
- Don't persist: Auth tokens (use Supabase session), temporary UI state

**Skeleton Screens**:
- Pattern: Loading placeholders that match final content structure
- Implementation: React Native Paper Skeleton with animated wave
- Use cases: Profile loading, list loading, card loading

### Known Issues

**Pre-existing Test Failures** (Documented in claudedocs/pre-existing-test-issues.md):
- 7 failing unit test suites (pre-existing, not related to Phase 10 work)
- 456 TypeScript errors in old test files
- 78 lint warnings
- Supabase functions not included in tsconfig.json
- All new Phase 10 code is working correctly and type-safe

### Next Steps

- T149: Verify all acceptance scenarios from spec.md pass
- T150: Run bundle size analysis and verify targets met
- Address pre-existing test issues in separate maintenance task
- Prepare for feature branch merge to main
